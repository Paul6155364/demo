JVM中的类的加载器主要有三种:启动类加载器，拓展类加载器，应用类加载
系统提供的3种类加载器
1）、启动类加载器（Bootstrap ClassLoader）：负责将存放在<JAVA_HOME>\lib目录中，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。（注：仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）
2）、扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录中的，或被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
3）、应用程序类加载器（Application ClassLoader）：负责加载用户路径（ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，一般情况下该类加载是程序中默认的类加载器。
类加载器之间的这种层次关系就是双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应有自己的父类加载器
双亲委派原则的好处：
1）、避免重复加载同一个类；
2）、防止用户任意修改java中的类；
双亲委派：如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一层次的类加载器都是这样，因此所有的加载请求最终都应该传送到底层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试去加载
类加载过程
1、加载
    将class文件字节码加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这类到java.lang.Class对象
2、链接
    将Java类的二进制代码合并到Jvm到运行状态之中到过程
    1、验证
        确保加载类到信息符合Jvm规范，没有安全方面到问题
    2、准备
        正式为类变量（static）分配内存并设置类变量默认初始值到阶段，这些内存都将在方法区中进行分配
    3、解析
        虚拟机常量池到符号引用（常量名）替换为直接引用（地址）到过程
3、初始化
    执行类构造器<clinit>()方法到过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量到赋值动作和静态代码块中到语句合并产生到。（类构造器是构造类信息的，不是构造该类对象的构造器）
    当初始化一个类时，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
    虚拟机会保证一个类的<clinit>()方法在多线程环境中贝正确加锁和同步
4、使用
5、销毁